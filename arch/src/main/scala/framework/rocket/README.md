# BuckyBall Rocket Core Framework

This directory contains the customized Rocket core implementation in the BuckyBall framework. The architecture is built on top of the Chipyard/Rocket-chip framework, with extensive extensions and modifications to support BuckyBall's custom RoCC coprocessors. BuckyBall's design philosophy is to maintain compatibility with upstream Rocket-chip while implementing functional extensions through parallel class hierarchies, thus avoiding maintenance issues from directly modifying upstream code while fully leveraging Rocket-chip's mature architecture.

In Chipyard's hierarchy, the top level is the SoC subsystem, responsible for integrating multiple processor cores, cache subsystems, interconnect buses, memory controllers, and various peripherals. BuckyBall defines its subsystem implementation through `RocketSubsystem.scala`, where the `RocketSubsystem` class extends Chipyard's `BaseSubsystem` and mixes in multiple traits to obtain necessary functional support. These traits include `InstantiatesHierarchicalElements` for managing hierarchical component instantiation, `HasTileNotificationSinks` and `HasTileInputConstants` for handling inter-tile communication, `CanHavePeripheryCLINT` and `CanHavePeripheryPLIC` for interrupt controller support, and `HasPeripheryDebug` for debug support. Through this multiple inheritance design pattern, BuckyBall can reuse most of Chipyard's infrastructure while performing customized extensions where needed. Importantly, `RocketSubsystem` also defines `RocketTileAttachParamsBB` to describe how to connect BuckyBall's version of Rocket tiles to the subsystem, with this parameter class specifying tile configuration parameters and cross-clock-domain connection methods.

One level down is the tile level, where `RocketTileBB.scala` defines the complete implementation of a single Rocket tile. In Chipyard's design, a tile is a relatively independent processing unit containing the processor core, L1 instruction and data caches, optional vector units, RoCC coprocessor interface, and system bus connection interfaces. The `RocketTileBB` class obtains basic tile functionality by extending `BaseTile` while mixing in several key traits. `SinksExternalInterrupts` and `SourcesExternalNotifications` handle reception and transmission of external interrupts and notifications, `HasLazyRoCCBB` is a BuckyBall-specific trait for supporting BuckyBall's RoCC coprocessor framework, `HasHellaCache` provides the interface to L1 data cache, and `HasICacheFrontend` provides the instruction fetch frontend implementation. This multi-trait composition design allows `RocketTileBB` to obtain all necessary functionality while maintaining code modularity and maintainability. Notably, `RocketTileBB` defines its own parameter type `RocketTileParamsBB`, which contains all tile configuration information including core parameters, cache parameters, BTB parameters, and provides an instantiation interface through the `InstantiableTileParams` trait.

Inside the tile, the most core component is the processor core itself, implemented by `RocketCoreBB.scala`. This file contains a reimplementation of the original Rocket core, where the `RocketBB` class extends `CoreModule` and mixes in `HasRocketCoreParameters` and `HasRocketCoreIOBB` traits. `CoreModule` provides the basic framework for core modules, `HasRocketCoreParameters` provides access interfaces to various core parameters, while `HasRocketCoreIOBB` defines BuckyBall-specific core IO interfaces. The key difference of this IO interface from the standard Rocket core IO is using `RoCCCoreIOBB` instead of standard `RoCCCoreIO`, enabling support for BuckyBall-specific RoCC interface extensions. In the core implementation, the most critical modification is instruction decode table handling. The original Rocket core decides whether to include RoCC instruction decode logic based on the `usingRoCC` parameter, but since BuckyBall uses `BuildRoCCBB` instead of standard `BuildRoCC`, this causes `usingRoCC` to return false, preventing RoCC instructions from being properly decoded. To solve this problem, BuckyBall forces inclusion of `RoCCDecode` in the decode table, ensuring custom instructions can be correctly recognized and processed.

RoCC coprocessor support is implemented through `LazyRoCCBB.scala`, which defines BuckyBall's RoCC framework. The `HasLazyRoCCBB` trait is the core of this framework, responsible for managing RoCC coprocessor instantiation and connections. This trait creates corresponding RoCC instances based on `BuildRoCCBB` configuration and allocates independent CSR address spaces for each RoCC. The `HasLazyRoCCModuleBB` trait handles RoCC connections at the module level, instantiating `RoccCommandRouterBB` for instruction routing. This router decides which specific RoCC instance to send instructions to based on instruction opcode, and also arbitrates responses from different RoCCs before returning them to the core. The router design considers concurrent instruction execution and response ordering, ensuring system correctness and performance.

`CSRBB.scala` contains a reimplementation of the control and status register subsystem, which is one of the most complex parts of the BuckyBall framework. The CSR subsystem handles all control and status register accesses, including standard RISC-V CSRs and BuckyBall-specific extended CSRs. This implementation is based on the original Rocket CSR implementation but extended for BuckyBall's needs, supporting more flexible CSR address allocation and more complex read/write logic. Particularly for RoCC-related CSRs, BuckyBall implements a dynamic address allocation mechanism that allows different RoCC instances to have independent CSR spaces, avoiding address conflicts.

`RoCCFragments.scala` defines BuckyBall's RoCC interface data structures, which maintain compatibility with standard RoCC interfaces while providing additional extension capabilities. This includes extended command formats, response formats, and additional control signals. These interface definitions form the foundation of the entire BuckyBall RoCC ecosystem, ensuring correct communication between different components.

`Configs.scala` contains rich configuration definitions that specify various hardware parameters through Chipyard's configuration system. The configuration system uses functional programming concepts, building complex system configurations through composition of configuration functions. BuckyBall's configuration defines how to integrate BuckyBall-specific components into the entire system, including RoCC configuration, CSR configuration, and various performance parameter settings.

The most critical design challenge in the entire architecture lies in parameter passing and configuration consistency. The Chipyard/Rocket-chip framework extensively uses Scala's implicit parameter mechanism and the `Parameters` configuration system, which allows configuration information to be passed and overridden throughout the hardware hierarchy. The main problem BuckyBall faces is how to ensure its configuration information (especially RoCC configurations defined in `BuildRoCCBB`) can be correctly passed to all components that need it. Since the original Rocket core only recognizes `BuildRoCC` and is unaware of `BuildRoCCBB`, BuckyBall adopts an elegant solution: when `RocketTileBB` creates a `RocketBB` core instance, it dynamically modifies the `Parameters` object passed to the core, merging the contents of `BuildRoCCBB` into `BuildRoCC`. From the core's perspective, BuckyBall's RoCC appears just like a standard RoCC, and all logic based on `BuildRoCC` works correctly, including `usingRoCC` parameter calculation, port count calculation, and instruction decode table construction. This design maintains compatibility with upstream code while achieving the functional extensions required by BuckyBall, exemplifying an elegant application of the adapter pattern in software engineering.
