#! /usr/bin/env python3

import sys
import shutil
import argparse
import subprocess
import os
import time
import socket
import signal
import threading
import http.server
import socketserver
import shlex
from typing import Optional, List, Dict
import json

workflow_dir = os.path.dirname(os.path.abspath(__file__))

def parse_args(argv: list[str]) -> argparse.Namespace:
  parser = argparse.ArgumentParser(
    prog="bbdev",
    description="Development tool for buckyball project",
    formatter_class=argparse.RawTextHelpFormatter,
  )
  
  # 全局参数
  parser.add_argument("--port", type=int, default=5000, help="Port for dev server (default: 5000)")
  
  # 子命令解析器
  subparsers = parser.add_subparsers(dest="command", help="Available commands")
  
  # ===== start 子命令 ==============================================================================
  start_parser = subparsers.add_parser("start", help="Start dev server")
  
  # ===== stop 子命令 ==============================================================================
  stop_parser = subparsers.add_parser("stop", help="Stop dev server")
  stop_group = stop_parser.add_mutually_exclusive_group(required=False)
  stop_group.add_argument("--all", action="store_true", help="Stop all servers")
  
  # ===== verilator 子命令 =========================================================================
  verilator_parser = subparsers.add_parser("verilator", help="Verilator operations")
  # verilator 的互斥选项组 - 只能选择一个操作
  verilator_group = verilator_parser.add_mutually_exclusive_group(required=True)
  verilator_group.add_argument("--clean", action="store_true", help="Clean verilator build directory")
  verilator_group.add_argument("--verilog", action="store_true", help="Generate verilog files from chisel")
  verilator_group.add_argument("--build", type=str, nargs="?", const="", metavar="ARGS", 
                              help="Build verilator simulation executable. Args: \"[--job <num>]\"")
  verilator_group.add_argument("--sim", type=str, nargs="?", const="", metavar="ARGS",
                              help="Run verilator simulation. Args: \"--binary <path> [--batch]\"")
  verilator_group.add_argument("--run", type=str, nargs="?", const="", metavar="ARGS",
                              help="Integrated build+sim+run. Args: \"--binary <path> [--batch] [--job <num>]\"")
  
  # ===== vcs 子命令 =========================================================================
  vcs_parser = subparsers.add_parser("vcs", help="vcs operations")
  # vcs 的互斥选项组 - 只能选择一个操作
  vcs_group = vcs_parser.add_mutually_exclusive_group(required=True)
  vcs_group.add_argument("--clean", action="store_true", help="Clean vcs build directory")
  vcs_group.add_argument("--verilog", action="store_true", help="Generate verilog files")
  vcs_group.add_argument("--build", type=str, nargs="?", const="", metavar="ARGS", 
                            help="Build vcs simulation executable. Args: \"[--job <num>]\"")
  vcs_group.add_argument("--sim", type=str, nargs="?", const="", metavar="ARGS",
                            help="Run vcs simulation. Args: \"--binary <path> [--batch]\"")
  vcs_group.add_argument("--run", type=str, nargs="?", const="", metavar="ARGS",
                            help="Integrated build+sim+run. Args: \"--binary <path> [--batch] [--job <num>]\"")
  
  # ===== sardine 子命令 =========================================================================
  sardine_parser = subparsers.add_parser("sardine", help="sardine operations")
  sardine_group = sardine_parser.add_mutually_exclusive_group(required=True)
  sardine_group.add_argument("--run", type=str, nargs="?", const="", metavar="ARGS",
                            help="Run sardine. Args: \"--workload <path>\"")

  # ===== agent 子命令 =========================================================================
  agent_parser = subparsers.add_parser("agent", help="agent operations")
  agent_group = agent_parser.add_mutually_exclusive_group(required=True)
  agent_group.add_argument("--chat", type=str, nargs="?", const="", metavar="ARGS",
                            help="Run agent. Args: \"--message <message>\", \"--model <model>\"")

  # ===== workload 子命令 =========================================================================
  workload_parser = subparsers.add_parser("workload", help="workload operations")
  workload_group = workload_parser.add_mutually_exclusive_group(required=True)
  workload_group.add_argument("--build", type=str, nargs="?", const="", metavar="ARGS",
                            help="Build workload. ")
  
  # ===== doc 子命令 =========================================================================
  doc_parser = subparsers.add_parser("doc", help="doc operations")
  doc_group = doc_parser.add_mutually_exclusive_group(required=True)
  doc_group.add_argument("--deploy", action="store_true", help="Deploy doc. ")


  # 解析参数，允许未知参数（这样 --port 可以在子命令中工作）
  args, unknown = parser.parse_known_args(argv)
  
  # 如果 --port 在未知参数中，手动处理
  for i in range(len(unknown)):
    if unknown[i] == "--port":
      try:
        args.port = int(unknown[i+1])
        unknown = unknown[i+2:]  # 移除已处理的参数
        break
      except ValueError:
        pass
  
  # 如果有其他未知参数，报错
  if unknown:
    parser.error(f"unrecognized arguments: {' '.join(unknown)}")
  
  return args


def extract_command_info(args):
  """通用的命令信息提取器，适用于所有命令"""
  # 基础返回结构
  result = {
    "command": getattr(args, 'command', None),
    "operation": None,
    "args": {}
  }
  
  # 动态提取操作类型（遍历args的所有属性）
  for attr_name in dir(args):
    # 跳过内置属性和已知的非操作属性
    if attr_name.startswith('_') or attr_name in ['command', 'port']:
      continue
    
    attr_value = getattr(args, attr_name)
    # 找到值为True或非空字符串的属性（跳过None和False）
    if attr_value is not None and attr_value is not False:
      result["operation"] = attr_name
      if attr_value is True:
        # 布尔操作，如 --clean, --verilog
        result["args"] = {}
      else:
        # 带参数的操作，如 --sim "arg_string"
        # 解析参数字符串
        args_dict = {}
        if attr_value:
          try:
            # use shlex to parse args
            arg_tokens = shlex.split(attr_value)
            i = 0
            while i < len(arg_tokens):
              token = arg_tokens[i]
              if token.startswith('--'):
                # long option
                option_name = token[2:]  # remove --
                if i + 1 < len(arg_tokens) and not arg_tokens[i + 1].startswith('-'):
                  # next token is value
                  args_dict[option_name] = arg_tokens[i + 1]
                  i += 2
                else:
                  # boolean flag
                  args_dict[option_name] = True
                  i += 1
              elif token.startswith('-') and len(token) == 2:
                # short option
                option_name = token[1:]  # remove -
                if i + 1 < len(arg_tokens) and not arg_tokens[i + 1].startswith('-'):
                  # next token is value
                  args_dict[option_name] = arg_tokens[i + 1]
                  i += 2
                else:
                  # boolean flag
                  args_dict[option_name] = True
                  i += 1
              else:
                # position argument, skip
                i += 1
          except ValueError as e:
            print(f"Error parsing arguments: {e}")
        result["args"] = args_dict
      break
  
  return result


if __name__ == "__main__":
  args = parse_args(sys.argv[1:])
  cmd_info = extract_command_info(args)
  
  # print(f"Command: {cmd_info['command']}")
  # print(f"Operation: {cmd_info['operation']}")
  # print(f"Arguments: {cmd_info['args']}")
  
  if cmd_info['command'] == "start":
    print(f"Starting dev server on port {args.port}")
    subprocess.run(["npx", "motia", "dev", "--port", str(args.port)], cwd=workflow_dir, check=True)
    
  elif cmd_info['command'] == "stop":
    if cmd_info['operation'] == "all":
      print("Stopping all servers")
      subprocess.run("kill -9 $(ps aux | grep \'[m]otia\' | awk \'{print $2}\')", shell=True, check=False, text=True)
    else:
      print(f"Stopping server on port {args.port}")
      subprocess.run(f"kill -TERM $(lsof -t -i :{args.port})", shell=True, check=False, text=True)

  elif cmd_info['command'] in ["verilator", "vcs", "sardine", "agent", "workload", "doc"]:
    api_path = f"/{cmd_info['command']}/{cmd_info['operation']}"
    json_data = json.dumps(cmd_info['args'])
    subprocess.run(["curl", "-X", "POST", f"http://localhost:{args.port}{api_path}", "-H", "Content-Type: application/json", "-d", json_data], cwd=workflow_dir, check=True)
    # print(f"\ncurl -X POST http://localhost:{args.port}{api_path} -H \"Content-Type: application/json\" -d '{json_data}'")
  else:
    print(f"Unknown command: {cmd_info['command']}")
    print("Available commands: start, stop, verilator, vcs, sardine, agent, workload, doc")
    sys.exit(1)

  