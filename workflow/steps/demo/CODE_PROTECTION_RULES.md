# 代码保护规则

## 核心原则

**现有代码是正确的，只添加不修改！**

## 所有 Agent 必须遵守的规则

### ❌ 禁止的操作

1. **删除已有代码**
   - 不要删除任何现有文件
   - 不要删除现有代码块
   - 不要删除现有函数/方法

2. **修改已有实现**
   - 不要修改已有 Ball 的实现
   - 不要修改已有的系统配置
   - 不要"优化"现有代码

3. **重构现有功能**
   - 不要重构已有架构
   - 不要调整已有模块结构
   - 不要"改进"现有实现

### ✅ 允许的操作

1. **添加新代码**
   - 添加新的 Ball 实现
   - 添加新的 ISA 指令定义
   - 添加新的测试用例

2. **在指定位置追加**
   - 在 `DomainDecoder.scala` 中添加新 Ball 解码条目
   - 在 `busRegister.scala` 中追加新 Ball ID
   - 在 `isa.h` 中添加新指令 enum

3. **创建新文件**
   - 创建新的 Ball 模块文件
   - 创建新的 spec.md
   - 创建新的测试文件

## 各 Agent 的职责与权限

### Spec Agent
**权限**：文件操作 + Deepwiki（❌ 无编译/测试权限）

**职责：**
- ✅ 只定义新 Ball 的规格
- ❌ 不要求修改已有 Ball
- ❌ 不建议重构现有系统

### Code Agent
**权限**：文件操作 + Deepwiki（❌ 无编译/测试权限）

**前置检查（必须先执行）：**
1. ✅ 检查 spec.md 是否存在
2. ❌ 如果 spec.md 不存在：停止并反馈给 master_agent

**执行顺序（严格）：**
1. **阶段 1：RTL 实现**
   - ✅ Chisel 硬件模块（完整实现）
   - ✅ ISA API 定义（所有函数）
   - ✅ 系统注册（DomainDecoder/BBus/RS）

2. **阶段 2：测试用例**
   - ✅ 只有 RTL 完全实现后才能写测试
   - ✅ 测试基于已定义的 ISA API

**禁止操作：**
- ❌ 不删除或修改任何已有代码
- ❌ 不重构已有实现
- ❌ 不要在 RTL 未完成时就写测试
- ❌ 不能运行编译或测试（无权限）

### Review Agent
**权限**：文件读取 + 搜索（❌ 无编译/测试权限）

**审查顺序（必须）：**
1. ✅ 优先检查 RTL 是否完整
2. ✅ 检查是否存在 RTL 未完成就写测试的情况
3. ✅ 检查是否删除/修改了已有代码

**审查不通过情况：**
- ❌ RTL 未完成
- ❌ RTL 未完成但已写测试（流程错误）
- ❌ 删除/修改了已有代码

### Verify Agent
**权限**：文件操作 + ✅ **Workflow API**（编译、测试）

**职责：**
- ✅ 只运行测试验证
- ✅ 可以运行编译和测试（有权限）
- ❌ 不修改代码
- ❌ 测试失败时报告问题，不尝试修复

### Master Agent
**权限**：✅ 完全权限（所有工具）

**职责：**
- ✅ 协调整体开发流程
- ✅ 调用其他 agent（独有权限）
- ✅ 明确告知 code_agent：先 RTL 后测试
- ✅ 必要时可以直接操作所有工具
- ❌ 如果 review_agent 报告流程错误或删除了现有代码，要求 code_agent 重新实现

## 典型场景

### 场景 1: 添加新 Ball 到 DomainDecoder

**错误做法：**
```scala
// ❌ 修改了现有的 GELU 配置
object DomainDecoder {
  val mappings = Seq(
    BitPat("b00") -> "gelu",  // 修改了这行
    BitPat("b01") -> "new_ball"
  )
}
```

**正确做法：**
```scala
// ✅ 只追加新条目
object DomainDecoder {
  val mappings = Seq(
    BitPat("b00") -> "relu",  // 保持不变
    BitPat("b01") -> "gelu",  // 保持不变
    BitPat("b10") -> "new_ball"  // 只添加新的
  )
}
```

### 场景 2: 添加新 ISA 指令

**错误做法：**
```c
// ❌ 重新定义了已有的 enum
typedef enum {
  RELU = 0,  // 修改了顺序
  GELU = 1,
  NEW_BALL = 2
} InstructionType;
```

**正确做法：**
```c
// ✅ 只在末尾追加
typedef enum {
  RELU = 0,     // 保持不变
  GELU = 1,     // 保持不变
  NEW_BALL = 2  // 只添加新的
} InstructionType;
```

## Review Agent 检查清单

- [ ] 是否有文件被删除？
- [ ] 是否有已有代码行被删除？
- [ ] 是否有已有 Ball 实现被修改？
- [ ] 是否有已有配置被调整？
- [ ] 是否有已有函数被重构？

**如果任何一项为"是"，审查不通过！**

## 违规处理

如果发现违规：

1. **Review Agent**：审查不通过，给出具体违规位置
2. **Master Agent**：要求 Code Agent 重新实现
3. **Code Agent**：恢复被删除/修改的代码，只在适当位置添加新代码

## 执行顺序要求

### Code Agent 必须遵守的顺序

**错误流程：**
```
❌ 开始实现
  ↓
部分 RTL（还有 TODO）
  ↓
开始写测试用例（错误！RTL 未完成）
  ↓
Review 发现流程错误 → 不通过
```

**正确流程：**
```
✅ 开始实现
  ↓
完成所有 RTL 模块（Chisel + ISA API + 系统注册）
  ↓
确认 RTL 100% 完成（无 TODO，无空实现）
  ↓
编写测试用例（基于已定义的 ISA API）
  ↓
Review 检查完整性 → 通过
  ↓
Verify 测试验证
```

### Review Agent 的检查顺序

1. **第一优先级**：检查 RTL 是否完整
   - Chisel 模块是否全部实现？
   - ISA API 是否定义完整？
   - 系统注册是否完成？

2. **第二优先级**：检查流程是否正确
   - 如果 RTL 未完成，不应该有测试用例
   - 如果发现 RTL 未完成但有测试 → 审查不通过

3. **第三优先级**：检查代码质量
   - 无 TODO/FIXME
   - 无空实现
   - 无删除/修改已有代码

## 记住

1. **原有代码是经过验证的正确实现，新功能只能通过添加来实现，不能通过修改来实现！**
2. **必须先完成 RTL，再编写测试！测试基于 RTL，不能在 RTL 之前！**
